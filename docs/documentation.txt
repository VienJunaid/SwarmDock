Core data structs (plain, boring, stable)

IDs

RobotId, TaskId, MapNodeId (strong typedefs or wrappers)

Geometry

struct Pose2 { double x, y, theta; }

struct Twist2 { double vx, vy, w; } (optional)

Robot state

enum class RobotMode { Idle, Executing, Charging, Error };

struct RobotState { RobotId id; Pose2 pose; RobotMode mode; double battery; TaskId active_task; }

Task / Mission

enum class TaskStatus { Queued, Assigned, InProgress, Done, Failed };

struct Task { TaskId id; Pose2 pickup; Pose2 dropoff; TaskStatus status; RobotId assigned_to; int priority; }

Command

enum class CommandType { GoTo, Pick, Drop, Stop };

struct Command { RobotId robot; CommandType type; Pose2 target; }

Core classes (first “skeleton”)
Robot

Represents one robot from the controller’s POV.

fields: RobotState state; std::deque<Command> queue;

methods:

const RobotState& get_state() const

void apply_telemetry(const RobotState& new_state) (from sim or real robot)

bool is_available() const (Idle + no active task)

void enqueue(Command c)

std::optional<Command> next_command() (pop/front)

void clear_commands()

TaskQueue

Just holds tasks and lets you query them.

fields: std::vector<Task> tasks;

methods:

TaskId add(Task t)

std::vector<Task*> queued()

Task* get(TaskId id)

void mark_status(TaskId id, TaskStatus s)

Dispatcher (assignment)

The simplest “brain”: match queued tasks to idle robots.

methods:

std::optional<std::pair<TaskId, RobotId>> pick_assignment(const std::vector<Robot>& robots, TaskQueue& tasks)

v0 logic: first queued task + first idle robot

v1 logic: choose robot closest to pickup (distance)

FleetController

The orchestrator.

fields: std::unordered_map<RobotId, Robot> robots; TaskQueue tasks; Dispatcher dispatcher;

methods:

void register_robot(RobotId id, Pose2 start)

TaskId submit_task(Pose2 pickup, Pose2 dropoff, int priority=0)

void update_robot_state(RobotId id, RobotState st)

void tick(double dt) ← your main loop

std::vector<Command> collect_outgoing_commands() (what to send to robots)

tick(dt) responsibilities

Assign queued tasks to available robots (Dispatcher).

For each assigned task, generate a tiny command script:

GoTo pickup → Pick → GoTo dropoff → Drop

Update task states when robot reports completion (for now, fake it in sim).